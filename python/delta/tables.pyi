from typing import overload, Dict, Optional, Union

from py4j.java_collections import MapConverter as MapConverter  # type: ignore[import]
from py4j.java_gateway import JavaObject  # type: ignore[import]

from pyspark import SparkContext as SparkContext
from pyspark.sql import SQLContext as SQLContext, SparkSession as SparkSession

from pyspark.sql import Column, DataFrame
from pyspark.sql.types import StructType

_StringOrColumn = Union[str, Column]

class DeltaTable:
    def __init__(self, spark: SparkSession, jdt: JavaObject) -> None: ...
    def toDF(self) -> DataFrame: ...
    def alias(self, aliasName: str) -> DeltaTable: ...
    def generate(self, mode: str) -> None: ...
    def delete(self, condition: Optional[_StringOrColumn] = ...) -> None: ...
    @overload
    def update(self, condition: _StringOrColumn, set: Dict[str, _StringOrColumn]) -> None: ...
    @overload
    def update(self, *, set: Dict[str, _StringOrColumn]) -> None: ...
    def merge(self, source: DataFrame, condition: _StringOrColumn) -> DeltaMergeBuilder: ...
    def vacuum(self, retentionHours: Optional[float] = ...) -> DataFrame: ...
    def history(self, limit: Optional[int] = ...) -> DataFrame: ...
    @classmethod
    def convertToDelta(cls, sparkSession: SparkSession, identifier: str, partitionSchema: Optional[Union[str, StructType]] = ...) -> DeltaTable: ...
    @classmethod
    def forPath(cls, sparkSession: SparkSession, path: str) -> DeltaTable: ...
    @classmethod
    def isDeltaTable(cls, sparkSession: SparkSession, identifier: str) -> bool: ...

class DeltaMergeBuilder:
    def __init__(self, spark: SparkSession, jbuilder: JavaObject) -> None: ...
    @overload
    def whenMatchedUpdate(self, condition: _StringOrColumn, set: Dict[str, _StringOrColumn]) -> DeltaMergeBuilder: ...
    @overload
    def whenMatchedUpdate(self, *, set: Dict[str, _StringOrColumn]) -> DeltaMergeBuilder: ...
    def whenMatchedUpdateAll(self, condition: Optional[_StringOrColumn] = ...) -> DeltaMergeBuilder: ...
    def whenMatchedDelete(self, condition: Optional[_StringOrColumn] = ...) -> DeltaMergeBuilder: ...
    @overload
    def whenNotMatchedInsert(self, condition: _StringOrColumn, values: Dict[str, _StringOrColumn]) -> DeltaMergeBuilder: ...
    @overload
    def whenNotMatchedInsert(self, *, values: Dict[str, _StringOrColumn] = ...) -> DeltaMergeBuilder: ...
    def whenNotMatchedInsertAll(self, condition: Optional[_StringOrColumn] = ...) -> DeltaMergeBuilder: ...
    def execute(self) -> None: ...
